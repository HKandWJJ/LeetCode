package Trick0287_findDuplicate;

/**
 * 寻找重复数:给定一个包含n + 1 个整数的数组nums ，其数字都在[1, n]范围内（包括 1 和 n），可知至少存在一个重复的整数。
 * 假设 nums 只有 一个重复的整数 ，返回这个重复的数 。
 * 你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。
 * *******************************************************************************************
 * 思路总结:
 * 1. 转化为链表有环问题:可以将数组 nums 看作是一个特殊的链表。对于数组中的每个索引 i，可以将 nums[i] 视为从索引 i 指向 nums[i] 的一个链接。
 *      由于数组中存在重复的数字，这就意味着在这个 “链表” 中会形成一个环。
 *      例如，假设有数组 nums = [1, 3, 4, 2, 2]，可以将其看作是这样的 “链表”：
 *      从索引 0 指向 nums[0] = 1，从索引 1 指向 nums[1] = 3，从索引 3 指向 nums[3] = 2，
 *      从索引 2 指向 nums[2] = 4，从索引 4 指向 nums[4] = 2，此时就形成了一个环。
 * 2. 快慢指针找环的相遇点:定义两个指针 slow 和 fast，初始时都指向数组的第一个元素，即 slow = 0，fast = 0。
 *      然后，slow 每次移动一步，即 slow = nums[slow]，fast 每次移动两步，即 fast = nums[nums[fast]]。
 *      这样，slow 和 fast 会在环中相遇。
 * 3. 找环的入口:当 slow 和 fast 相遇时，将 slow 重新指向数组的第一个元素，即 slow = 0。
 *      然后，slow 和 fast 每次移动一步，直到它们再次相遇。
 *      此时，相遇点就是环的入口，即重复的数字。
 * *******************************************************************************************
 * 时间复杂度:O(n)
 * 空间复杂度:O(1)
 */
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0, fast = 0;
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);
        slow = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
}
