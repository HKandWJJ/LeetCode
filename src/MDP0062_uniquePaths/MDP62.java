package MDP0062_uniquePaths;

import java.util.Arrays;

/**
 * 不同路径:m*n的网格，从左上角到右下角，每次只能向下或者向右移动一步，有多少种不同的路径
 * **********************************************************************
 * 思路总结:
 * 初始化第一行：因为在第一行的任何位置，只能从左边的位置到达，所以第一行的每个位置的路径数量都为 1。
 * 动态规划更新：对于其他位置 (i, j)，可以从上方的位置 (i - 1, j) 或者左方的位置 (i, j - 1) 到达。
 * 因此，到达位置 (i, j) 的路径数量等于到达位置 (i - 1, j) 的路径数量加上到达位置 (i, j - 1) 的路径数量。
 * 最终，数组 f 的最后一个元素 f[n - 1] 即为到达右下角位置的路径数量。
 */
class Solution_MDP {
    public int uniquePaths(int m, int n) {
        int[] f = new int[n];
        Arrays.fill(f, 1);
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                f[j] += f[j - 1];
            }
        }
        return f[n - 1];
    }
}
